# 代码规范

### 1.缩进

制表符是 8 个字符，因此缩进也是 8 个字符。缩进背后的整个想法是明确定义控制块开始和结束在哪里。

特别注意：在 switch 语句中简化多个缩进级别的首选方法是将“switch”及其从属“case”标签对齐在同一列中，而不是“双重缩进”“case”标签 . 例如。：

switch (suffix) {

case 'G':

case 'g':

mem <<= 30;

break;

case 'M':

case 'm':

mem <<= 20;

break;

case 'K':

case 'k':

mem <<= 10;

/\* fall through \*/

default:

break;

}

另外不要将多个语句放在一行中，除非您有要隐藏的东西：

if (condition) do\_this;

do\_something\_everytime;

也不要将多个赋值操作放在一行上。内核编码风格超级简单。 避免棘手的表达。

除了注释、文档和 Kconfig 之外，空格永远不会用于缩进，上面的例子是故意破坏的。

最后找一个像样的编辑器，不要在行尾留下空格。

### 2.打破长行和长字符串

编码风格是关于使用常用工具的可读性和可维护性。

行的长度限制为 80 列，这是一个强烈的首选限制。超过 80 列的语句将被分成合理的块，除非超过 80 列显著增加可读性并且不会隐藏信息。 后代总是比父母短很多，并且基本上放在右边。 这同样适用于具有长参数列表的函数头。 但是，永远不要破坏用户可见的字符串，例如 printk 消息，因为这会破坏 grep 获取它们的能力。

### 3.放置大括号和空格

C 风格中经常出现的另一个问题是大括号的位置。

与缩进尺寸不同，没有什么技术上的原因让我们选择一种放置策略而不是另一种，但是正如 Kernighan 和 Ritchie 向我们展示的一样，首选方式是将开括号放在一行的最后，将闭括号放在新行：

if (x is true) {

we do y

}

这可以用与所有非函数语句块（if, switch, for, while, do）。例如：

switch (action) {

case KOBJ\_ADD:

return "add";

case KOBJ\_REMOVE:

return "remove";

case KOBJ\_CHANGE:

return "change";

default:

return NULL;

}

但是有一个例外，即函数：函数的开括号在下一行的开头：

int function(int x)

{

body of function

}

请注意，闭括号所在的行是空的，除非在其后接同一语句的延续，即 while 在 do 语句后或 else 在 if 语句后，像这样：

do {

body of do-loop

} while (condition);

if (x == y) {

..

} else if (x > y) {

...

} else {

....

}

另外请注意：这种括号放置策略还可以在不损害可读性的前提下，最大程度地减少（或几乎）空行的数量。因此，由于屏幕上的新行供应是不可再生资源（请在此处考虑 25 行高的终端屏幕），你将有更多的空行可以用来编写注释。

不要在使用单个语句的地方不必要地使用大括号。

if (condition)

action();

和

if (condition)

do\_this();

else

do\_that();

如果多个条件语句中只有一个分支是单个语句，则不适用该规则。在这种情况下，需要在

所有的分支中都使用大括号：

if (condition) {

do\_this();

do\_that();

} else {

otherwise();

}

### 3.1空格

Linux 内核风格使用空格的样式（主要）取决于函数与关键字的用法。

在大多数关键字之后使用一个空格。值得注意的例外是 sizeof, typeof, alignof,

\_\_attribute\_\_，看起来有点像函数（通常在 Linux 中使用时需要加括号，虽然它们并没有要求，如在‘ struct fileinfo info; ’声明之后使用 ‘sizeof info’）。

因此，在这些关键字之后使用一个空格：

if, switch, case, for, do, while

但这些例外：sizeof, typeof, alignof, \_\_attribute\_\_，例如：

s = sizeof(struct file);

不要在带括号的表达式周围（内部）添加空格。下面是一个不好的例子：

s = sizeof( struct file );

在声明指针类型的数据或返回指针类型的函数时，\* 的首选用法是与数据名或函数名相邻，而不是与类型名相邻。例如：

char \*linux\_banner；

unsigned long long memparse(char \*ptr, char \*\*retptr);

char \*match\_strdup(substring\_t \*s);

在大多数二元和三元运算符的两侧使用一个空格，例如：

\= + - < > \* / % | & ^ <= >= == != ? :

但一元运算符之后不需要空格：

& \* + - \~ ! sizeof typeof alignof \_\_attribute\_\_ defined

后缀递增和递减一元运算符前没有空格：

\++ --

前缀递增和递减一元运算符后没有空格：

\++ --

使用 . 和 -> 运算符也不需要空格。

不要在行尾留下尾随空格。某些带有智能缩进的编辑器会在适当的时候在新行的开头插入空格，从而让你可以立即开始输入下一行代码。但是，如果最终没有在新行放置代码（留空行），某些编辑器不会删除空格，最终导致包含尾随空格的行。

Git 会警告你有关引入尾随空格的补丁，并且可以有选择地为你剥离尾随空格。但是如果应用一系列补丁，可能会由于上下文的更改导致该系列的后续补丁失败。

### 4.命名

C 是一门简洁的语言，所以命名也应该如此。与 Modula-2 和 Pascal 程序员不同，C 程序员不会使用诸如ThisVariableIsATemporaryCounter 之类的可爱命名。一个 C 程序员将命名该变量为 tmp，这样更容易编写，但同时也更难理解。

虽然不赞成使用大小写混合的命名方式，但描述性名称命名全局函数是必须的。

全局变量（仅在确实需要它们时才使用）与全局函数一样，都需要使用具有描述性的名称命名。如果现在有一个函数用来统计活跃用户数，应该将它命名为 count\_active\_users() 或类似的，而不应该命名为 cntusr()。

将函数的类型编码为名称（所谓的匈牙利命名法）是不好的——编译器无论如何都知道它们的类型并且可以检查它们，这样只会使程序员感到困惑。难怪 MicroSoft写出了很多古怪的程序。

局部变量名和应该简单明了，切中要害。如果你有一些随机的整数循环变量，可以将它命名为 i。如果该程序没有可能被误解，命名为 loop\_counter 是没有必要的。同样，tmp 几乎可以用于任何类型的保存临时值的变量。

如果你害怕混淆你的局部变量名，你会遇到另一个问题，它通常被称为“生长激素功能失调综合征”。参见第六章（函数）。

### 5.Typedefs

请不要使用诸如 vps\_t 之类的类型别名。对结构体和指针使用此类别名是一种错误。当你在源码中看到

vps\_t a;

这是什么意思？

相反，如果是这样

struct virtual\_container \*a;

你就能知道 a 实际上到底是什么。

许多人认为 typedefs 提高了可读性。但并不是这样，它们仅对以下内容有用：

完全不透明的对象（typedef 用于隐藏对象的内容）。

示例：pte\_t 等不透明的对象，你只能通过合适的访问函数进行访问。

_**注意：不透明性和访问函数并不是一种好的方法。之所以将它们用于类似 pte\_t 的对象，是因为它们确实存在不可访问的信息。**_

明确整数类型，这种抽象有助于避免混淆 int 和 long。u8/u16/u32 是完美的 typedefs。

_**注意：**_

_**对于类型 unsigned long，如果没有特别的原因那就没有理由使用 typedef unsigned long myflags\_t。但是如果有明确的理由说明为什么在某些情况下它可能是 unsigned int，而在另一些配置下可能是 unsigned long，那就继续使用 typedef。**_

当你使用 sparse 创建一个用于类型检查的新类型。

在某些特殊情况下，与 C99 标准类型相同的新类型。

尽管只需要很短的时间就可以使眼睛和大脑适应像这样的标准类型 uint32\_t，但是无论如何，有些人还是反对使用它们。

因此，Linux特定类型 u8/u16/u32/u64 及其有符号类型被允许定义别名，尽管它们在新代码中不是必须的。

当编辑已使用一种或另一组类型的现有代码时，应当遵循该代码中的现有选择。

在用户空间保持类型安全。

在用户空间可见的某些结构体中，我们不能使用 C99 标准类型，也不能使用类似 u32 的形式。因此，我们应当在所有与用户空间共享的结构的体中使用 \_\_u32 和类似类型。

也许还有其他情况，但是一个基本规则是：除非你可以清楚地匹配上述规则之一，否则不要使用 typedef。

通常，指针或者具有可以合理地直接访问元素的结构体永远都不应该使用 typedef。

### 6.函数

函数应该简洁而优美，每个函数只做一件事。它们应该适合一到两个文本（ISO/ANSIISO/ANSI 屏幕的尺寸是 80 ×× 24）。

函数的最大长度与该函数的复杂度和缩进程度成反比。因此，如果你有一个概念上很简单的函数，但是有一个长而是简单的 case 语句，通过这些语句完成很多不同的小任务，那么让该函数更长是可行的。

但是，如果你有一个复杂的函数，并且怀疑一般人无法理解该函数的全部含义，那么你应该更加严格地遵守最大长度限制，并使用具有描述性名称的辅助函数（如果你认为该辅助函数对性能至关重要，可以将其设置为内联函数）。

函数的另一个度量是局部变量的数量，它们不应该超过 5-10 个，否则就是你的函数有什么问题。重新规划该函数，考虑将其拆分为较小的部分。人脑通常可以轻松地跟踪大约 7 种不同的事物，再多就会变得混乱。你知道自己很聪明，但是也许你想轻松理解 2 周前做的工作。

在源文件中，用一个空行分割函数。如果需要导出该函数，则 EXPORT 宏应该紧跟在函数结束的括号行之后。例如：

int system\_is\_up(void)

{

return system\_state == SYSTEM\_RUNNING;

}

EXPORT\_SYMBOL(system\_is\_up);

函数原型应该包含参数名称及其数据类型。尽管这不是 C 语言所必需的，但我们建议在 Linux中这样做，因为它是一种简单的为读者添加有效信息的方法。
